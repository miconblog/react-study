# 리덕스 기본 

## 오늘 다룰 내용
1. 지난 시간 리뷰 
1. 리액트와 리덕스 연결하기
1. 리듀서 개념 이해
1. 리듀서 테스트 코드 만들기 
1. redux-immutable-state-invariant 미들웨어 추가



## 지난시간 리뷰 
 - [과제] counter 액션 생성자를 이용해 React 코드에서 액션을 실행해볼것.
 - 들어가기 앞서서.. Webpack root resolve 설정하기
 - 웹팩 resolve 설정하면, 
 


## 리액트 바인딩 
리액트와 리덕스를 연결하는 방법은 정형화된 패턴으로 되어 있다. 

``` 
npm install react-redux --save 
```

- 먼저 리액트 바인딩 모듈에 포함되어 있는 Provider를 이용해 store를 주입한다. 
여기서 Provider의 역할은 모든 하위 컴포넌트에 자동으로 props를 주입하기 위함이다.

```
// index.js 

import { createStore } from 'redux';
import { Provider } from 'react-redux';

ReactDOM.render(
  <Provider store={store}>
    <Router history={browserHistory} routes={routes} />
  </Provider>
  , document.getElementById('root'));

```


- 리액트 바인딩은 react-redux의 connect 함수를 이용한다.




``` 
import { connect } from 'react-redux';

class HomePage extends Component {}
...
.. 중략
...

export default connect({}, {})(HomePage);
```



#### [실습1] 




## 리덕스 흐름도

일단 리덕스 스토어를 만든다.!
``` 

  // 스토어 생성 
  const 스토어 = createStore( 리듀서 )    --- 1. 스토어에 리듀서를 등록한다.

  // 스토어를 모니터할 리스너 등록 
  스토어.subscribe( 리스너 )              --- 2. 여기서 리스너는 일반 함수다.
  
  // 스토어.subscribe 의 내부 동작 
  {
    var currentListeners = [];         --- 3. 내부적으로 관리하는 리스너 배열에 리스너를 추가한다. 
    currentListeners.push(리스너)
  }
  
``` 

이제 액션을 만들고 싶다.
```
  // 스토어에 액션 전달  
  스토어.dispatch( 액션 )                        --- 1. 여기서 액션은 플레인 객체다. { type }
 
  // 스토어.dispatch 의 내부 동작                  --- 2. 스토어에 등록된 리듀서를 실행해 새로운 상태를 만든다.
  {
    스토어_현재_상태 = 리듀서( 스토어_현재_상태, 액션 )   --- 3. 여기서 리듀서는 반드시 새로운 레퍼런스를 만들어서 반환해야한다. 
    
    for( 리스너 in currentListeners ) {         --- 4. 등록된 리스너를 모두 실행시킨다.
        리스너()
    }
  }
  
```     

## 다중 리듀서 
리덕스는 단일 스토어 구조를 가지고 있지만 아래와 같이 스토어 객체의 브랜치마다 전용 리듀서를 배치할수있다.
``` 
 스토어_상태_객체 = {
 
    로그인: 로그인_리듀서,
    라우터: 라우터_리듀서,
    todos: todoReducer
    ...
 
 }
```

다중 리듀서를 이용하려면 리덕스의 **combineReducers** 함수를 이용한다.
``` 
import { combineReducers }  from 'redux';

const 스토어 = createStore( 
  
  combineReducers({
    로그인: 로그인_리듀서,
    라우터: 라우터_리듀서,
    todos: todoReducer
  }) 

)
```
컴바인 리듀서는 키-벨류 쌍으로 리듀서를 관리하기 때문에 리듀서와 맵핑된느 키값이 스토어의 Flat한 객체 구조라고 생각하면 된다. 

위와 같이 컴바인 리듀서로 등록하면 dispatch 로 액션을 실행할때 아래와 같이 실행한 것과 동일한 과정으로 모든 리듀서를 실행한다.
  
```                 
const 로그인 = 로그인_리듀서(스토어_상태.로그인, 액션);
const 라우터 = 라우터_리듀서(스토어_상태.라우터, 액션);
const todos = todoReducer(스토어_상태.todos, 액션); 

스토어_상태 = {
  로그인,
  라우터,
  todos
}

```


## Presentational 컴포넌트 VS Container 컴포넌트

|               | Presentational Components        | Container Components                          |  
| --------------|:--------------------------------:|:---------------------------------------------:|
| 목적           | 어떻게 보일꺼냐? (markup, styles)    | 어떻게 동작할꺼냐? (data fetching, state updates)  |   
| 리덕스 인지유무   | 모른다. 	                       | 안다                                           |
| 데이터를 읽어오는곳	| 프로퍼티에서 가져온다.                 | 리덕스 상태를 모니터 한다.                          | 
| 데이터 변경      | 프로퍼티가 변경되면 자동 전파 된다.	   | 리덕스 액션이 수행되면 변경된다.                      | 
| Are written	| By hand	                       | Usually generated by React Redux              | 



## 참고문서 
1. 풀스택 튜토리얼 - http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html
2. 이뮤터블JS가 짜증난다면, seamless-immutable
