# 리덕스 설계

![](./images/redux-archictecture.png)


## Q. 어떤 값을 리듀서에 저장할 것인가?

필요한 상태값이 있다면 일단 컴포넌트 State에 먼저 저장하고 다른 페이지 혹은 컴포넌트에서도 이 값이 필요하다면 리듀서에 저장한다.
리듀서에 저장할때는 반드시 테스트 코드를 동반한다.

- 리듀서에 저장하는 값들은 기능별로 묶어서 저장하는게 상태값을 추적하기 쉽다. 


## Q. 리듀서를 Flat 하게 만드라는 말은 무슨 뜻인가? 

하나의 리듀서에 아래와 같은 복잡한 해쉬맵 상태를 가질 경우 데이터가 구조화 되는 것처럼 보이지만 실제로 상태 값을 추적하기 어렵고, 
이뮤터블한 상태를 만들기는 더더욱 어려워진다. 
``` 
{
  todos: [
    {}, {}
  ],
  filter: {
    name1: {},
    name2: {
      option: {
        subOption: {}
      }
    }
    ...
 }
}

```
따라서 중첩된 상태는 여러 리듀서로 역할을 나눠서 리듀서를 플랫하게 만드는 것이 중요하다.

```
 todoReducer: {},
 filterReuder: {}
```

그럼에도 불구하고 리듀서가 많아지면 액션이 발생할때마다 모든 리듀서가 반응하기 때문에 성능에는 좋지 않다. 
이럴때는 특정 액션에 특정 리듀서만 반응하도록 reselect 모듈을 이용하는 것도 좋은 방법이다.

## SPA 프로젝트의 경우 라우팅된 특정 페이지에서만 필요한 값들이 있다 이런 값들은 어떻게 저장할 것인가? 
- 페이지 단위로 상태값을 나누면 해당 페이지에 필요한 리듀서만 들여다 보면 되기 때문에 추적은 용이할수있지만 페이지 갯수만큼 늘어나는 것은 좋지 않다

```plain
[rootReducer]
   |
   |--- page1Reducer
   |--- page2Reducer
   |--- page3Reducer
   |--- page4Reducer
   |--- ...
```
- 페이지 안에서도 기능단위로 묶으면 페이지가 없어지거나 사라져도 기능이 유지되는한 리듀서는 오래 살아남을수있다. 


## Q. 프리젠테이션 컴포넌트에서 스토어 변경이 필요할때 어떻게 할것인가?

액션생성자를 이용하면 함수를 인자로 넘겨서 실행하는 방법과 다르게 this객체 없이 dispatch와 store를 그대로 사용할수있다. 

#### 방법1. 컨테이너 컴포넌트에서 프리젠테이션 컴포넌트로 액션 생성자 함수를 주입후 프리젠테이션 컴포넌트에서 직접 실행 (비추)
장점: 액션생성자를 주입 받았기 때문에 굳이 컨테이너 컴포넌트까지 이벤트를 버블링하지 않아도 된다. 
단점: 액션이 변경되면 컨테이너에서 주입된 모든 컴포넌트에서 수정해줘야한다. (강결합)

```plain
[컨테이너] 
   |
   | props:actionCreator 
   |
[프리젠테이션] --> this.props.actionCreator()
```


#### 방법2. 컨테이너 컴포넌트에서 콜백을 주입하고 이벤트로 되돌려 받아 처리한다 (권장)
장점: 약결합으로 변경에 용이하다. 
단점: Proxy 컴포넌트가 생기면 이벤트를 버블링을 해줘야하는 귀찮음이 존재한다.

```plain
[컨테이너]                          [컨테이너] --> this.props.actionCreator()   
   |                                 |
   | props: callback                 |
   |                                 |
[프리젠테이션] --> 이벤트 > 핸들러 --> this.props.callback() 

```




## 참고문서 
- 리덕스(Redux) 애플리케이션 설계 http://huns.me/development/1953

